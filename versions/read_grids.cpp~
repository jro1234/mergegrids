

#include <stdlib.h>
#include <dirent.h>
#include <stdio.h>
#include <omp.h>
#include <iostream>
#include <cstring>
#include <string>
#include <vector>

#define UHBD_HEADER_LENGTH 160
#define UHBD_HEADER_TITLE_LENGTH 72
// the final definition of block header lenghts
// are system dependent, thought it is dependent
// on the system that wrote the original file.
// make sure this is integrated to run on the 
// original system, immediately consolidating 
// these output grid files. 
// luckily most have sizeof(int) === 4.
#define UHBD_BLOCK_HEADER_LENGTH 6
// calc UHBD_BLOCK_LENGTH XXXXX
#define UHBD_TAIL_LENGTH 4

/*
          June 20, 2015
    This file was created by John Ossyra for the 
    purpose of merging UHBD-format binary grids.
    These are output from the SDA BD Simulations, 
    tracking the Occupancy Probability 
    Distrubution in the Simulation Geometry. The
    workflow creates multiple executions of SDA
    so gives multiple, and equivalent PDF Grids.
    These are combined into a single averaged
    PDF. Refer to following sources:

    http://www.ccs.neu.edu/course/com3620/projects/pbe/apbs-0.2.1/tools/mesh/uhbd_asc2bin.f
    http://www.ks.uiuc.edu/Research/vmd/plugins/doxygen/uhbdplugin_8C-source.html

    compile:
       $ g++ scripts/read_grids.cpp -fopenmp -std=c++11 -Wall -Wno-sign-compare -o read_grids
       $ g++ scripts/read_grids.cpp -fopenmp -std=c++11 -Wall -Wextra -Wno-sign-compare -g -O0 -fsanitize=address -o read_grids

    run with test case:
       $ ./read_grids goodone s3s5-4adv.s3-2i2p

*/


// some on internet say gnu c++ compiler
// doesn't work with omp_get_num_threads
// here is replacement, detecting threads
// by sinking each into reduction of 'n':
int omp_get_n_threads() {
  int n = 0;

  #pragma omp parallel reduction(+:n)
  n += 1;
  return n;
}


struct UHBD_Header {
  char raw[UHBD_HEADER_LENGTH + UHBD_TAIL_LENGTH];
  int  xm, ym, zm;
//  char  title[UHBD_HEADER_TITLE_LENGTH];
//  float ox, oy, oz;
//  float scale = 1;
//  float res;
};

struct UHBD_Block {
  float  factor = {0};
// extra calculations
//  float  sum = {0};
  int    n_entries;
  int    kk;
//  int    xm;
//  int    ym;
  float* data;
  int    header[UHBD_BLOCK_HEADER_LENGTH];
  char   raw_header[sizeof(int) * UHBD_BLOCK_HEADER_LENGTH + UHBD_TAIL_LENGTH];
  int    id = -1;
};

struct UHBD_Grid {
  UHBD_Header header;
  std::vector<UHBD_Block*> blocks;
  int   n_entries_block;
//  float sum = {0};
  int   n_blocks;
  float factor = {0};
  int   id = -1;
};


UHBD_Grid* Read_UHBD_Header (FILE* f_grid) {
  UHBD_Grid* data_grid = new UHBD_Grid;
  int   i_pars[8];

  // try to read in header, equivalent
  // of 160 chars. close if unable to 
  // read in header. 
  // there is a tail to header as well.
  if (fread(data_grid->header.raw, UHBD_HEADER_LENGTH + UHBD_TAIL_LENGTH, 1, f_grid) != 1) {
    printf("\nIncomplete header in file:  \n");
    printf("Size of header read:        %d\n", UHBD_HEADER_LENGTH + UHBD_TAIL_LENGTH);
    fclose(f_grid);
  } 
  else {
    memcpy(i_pars, data_grid->header.raw + UHBD_HEADER_TITLE_LENGTH + 8, 32);

    // then send to respective struct property
    data_grid->header.xm  = i_pars[5];
    data_grid->header.ym  = i_pars[6];
    data_grid->header.zm  = i_pars[7];
    data_grid->n_entries_block = data_grid->header.xm * data_grid->header.ym;
    data_grid->n_blocks = data_grid->header.zm;
  }

  return data_grid;
}

UHBD_Grid* Initialize_Target_Grid (UHBD_Grid* data_grid) {
  UHBD_Grid* target_grid = new UHBD_Grid;
  int i_pars[8];

  memcpy(target_grid->header.raw, data_grid->header.raw, UHBD_HEADER_LENGTH + UHBD_TAIL_LENGTH);
  memcpy(i_pars, target_grid->header.raw + UHBD_HEADER_TITLE_LENGTH + 8, 32);

  target_grid->header.xm  = i_pars[5];
  target_grid->header.ym  = i_pars[6];
  target_grid->header.zm  = i_pars[7];
  target_grid->n_entries_block = target_grid->header.xm * target_grid->header.ym;
  target_grid->n_blocks = target_grid->header.zm;

  for (int kk=0; kk<target_grid->n_blocks; kk++) {
    UHBD_Block* block = new UHBD_Block;
    float* data = new float[target_grid->n_entries_block]();

    // note difference between loop / file kk
    block->kk = kk + 1;
    block->data = data;
    block->n_entries = target_grid->n_entries_block;

    target_grid->blocks.push_back(block);
  }

  return target_grid;
}

void Write_UHBD_Block_Header (FILE* f_grid, UHBD_Block* block) {
  printf("\nblock header values to write:");
  for (int j=0; j<UHBD_BLOCK_HEADER_LENGTH; j++) {
    printf("   %d", block->header[j]);
  }
  printf("\n");
  fwrite(block->raw_header, sizeof(int) * UHBD_BLOCK_HEADER_LENGTH + UHBD_TAIL_LENGTH, 1, f_grid);
}

void Write_UHBD_Header (FILE* f_grid, UHBD_Header header) {
  fwrite(header.raw, UHBD_HEADER_LENGTH + UHBD_TAIL_LENGTH, 1, f_grid);
}

void Read_UHBD_Block (UHBD_Block* block, FILE* f_grid) {
    float* data = new float[block->n_entries];

//    printf("\nnew block, size: %d\n", block->n_entries);
    if (fread(block->raw_header, sizeof(int) * UHBD_BLOCK_HEADER_LENGTH + UHBD_TAIL_LENGTH, 1, f_grid) != 1) {
      printf("\nBlock header read error\n");
    }
    memcpy(block->header, block->raw_header, sizeof(int) * UHBD_BLOCK_HEADER_LENGTH);
    block->kk = block->header[2];
    if (block->header[2]%100==1)
    {
    printf("\nblock header values read:");
    for (int j=0; j<UHBD_BLOCK_HEADER_LENGTH; j++) {
      printf("   %d", block->header[j]);
    }
    printf("\n");
    }
    if (fread(data, sizeof(float), block->n_entries, f_grid) != block->n_entries) {
      printf("\nBlock read error\n");
    }
    else {
      block->data = data;
    }
}

void Read_UHBD_Grid (UHBD_Grid* data_grid, FILE* f_grid) {
  for (int kk=0; kk<data_grid->n_blocks; kk++) {
    UHBD_Block* block = new UHBD_Block;

    block->id = data_grid->id;
    block->factor = data_grid->factor;
    block->n_entries = data_grid->n_entries_block;
    ///////////////////////////////////////
    // development convenience structure //
    if (kk == 0)                       //
    {                                  //
    ///////////////////////////////////////
    Read_UHBD_Block(block, f_grid);
    ///////////////////////////////////////
    }                                  //
    // development convenience structure //
    ///////////////////////////////////////
    data_grid->blocks.push_back(block);
  }
}

void Reduce_UHBD_Block (UHBD_Block* target_block, UHBD_Block* data_block, float reduce_factor) {
//  printf("\nreduce factor: %f", reduce_factor);
//  printf("\nn entries    : %d\n", target_block->n_entries);

  for (int i=0; i<target_block->n_entries; i++) {
    if (data_block->data[i] > 1e-10) {
      target_block->data[i] += reduce_factor * data_block->data[i];
      if (target_block->kk == 1)
      {
      printf("\n non-zero value: block %d, grid %d:  %d  %f\n", data_block->kk, data_block->id, i, data_block->data[i]);
      printf("   new   value : block %d, grid %d:  %d  %f\n", target_block->kk, target_block->id, i, target_block->data[i]);
      }
    }
  }

  delete[] data_block->data;
  delete[] data_block;
}

void Reduce_Write_UHBD_Block (FILE* f_grid, UHBD_Block* first_block, UHBD_Block* second_block, float reduce_factor) {
//  printf("\nreduce factor: %f", reduce_factor);
//  printf("\nn entries    : %d\n", target_block->n_entries);
  Write_UHBD_Block_Header(f_grid, first_block);

  delete[] second_block->data;
  delete[] second_block;
  delete[] first_block->data;
  delete[] first_block;
}



void Reduce_UHBD_Grids (UHBD_Grid* target_grid, UHBD_Grid* data_grid) {
  for (int kk=0; kk<target_grid->n_blocks; kk++) {
    ///////////////////////////////////////
    // development convenience structure //
    if (kk == 0)                       //
    {                                  //
    ///////////////////////////////////////
    if (target_grid->blocks[kk]->factor < 1e-10) {
      memcpy(target_grid->blocks[kk]->raw_header, data_grid->blocks[kk]->raw_header, sizeof(int) * UHBD_BLOCK_HEADER_LENGTH + UHBD_TAIL_LENGTH);
      memcpy(target_grid->blocks[kk]->header, target_grid->blocks[kk]->raw_header, sizeof(int) * UHBD_BLOCK_HEADER_LENGTH);
    }
    Reduce_UHBD_Block(target_grid->blocks[kk], data_grid->blocks[kk], data_grid->blocks[kk]->factor);
    target_grid->blocks[kk]->factor += data_grid->factor;
    ///////////////////////////////////////
    }                                  //
    // development convenience structure //
    ///////////////////////////////////////
  }
  target_grid->factor += data_grid->factor;
}

void Merge_Write_UHBD_Block (FILE* f_target_grid, std::vector<UHBD_Grid*> vec_grids, int n_block, int n_grids) {
  vec_grids[0]->id = 0;
  for (int i=1; i<n_grids-1; i++) {
    vec_grids[i]->id = i;
    // reduce to 0th to store new values
    // except when only 1 left.
    // note all values are normalized to
    // their final contribution to the 
    // averaged grid with the first 
    // reduction factor, so it's one 
    // from here on out.
    Reduce_UHBD_Block(vec_grids[0]->blocks[n_block], vec_grids[i]->blocks[n_block], 1);
  }
  vec_grids[n_grids-1]->id = n_grids - 1;
  // last one goes to special reduce
  // which writes file instead of into
  // a memory location.
  if (n_block == 0) {
  Reduce_Write_UHBD_Block(f_target_grid, vec_grids[0]->blocks[n_block], vec_grids[n_grids-1]->blocks[n_block], 1);
  }
}


void Merge_Write_UHBD_Grid (FILE* f_target_grid, std::vector<UHBD_Grid*> vec_grids, int* parts_target_grid, int n_thread, int n_threads) {
  if (n_thread == 0) {
    Write_UHBD_Header(f_target_grid, vec_grids[n_thread]->header);
  }
  int blocks_interval[2];

  if (n_thread == 0) {
    blocks_interval[0] = 0;
    blocks_interval[1] = parts_target_grid[n_thread] - 1;
  }
  else {
    blocks_interval[0] = parts_target_grid[n_thread-1];
    blocks_interval[1] = parts_target_grid[n_thread] - 1;
  }
  printf("\n%d now merging final grid", n_thread);
  printf("\n%d partition of blocks: [ %d,  %d ]\n", n_thread, blocks_interval[0], blocks_interval[1]);

  // since we calculated a partition of this
  // grid structure for each thread, there 
  // is no overlap in the grid-block 
  // operations in this loop.
  for (int i=blocks_interval[0]; i<=blocks_interval[1]; i++) {
    // we use the first grid in the vector
    // of 1st round merger to store the 
    // 2nd round merger. the final pass
    // will directly write to file.
    printf("\n%d writing block# %d", n_thread, i);
    Merge_Write_UHBD_Block(f_target_grid, vec_grids, i, n_threads);
  }
}



void Merge_UHBD_Grids (int** lists_p_grids, std::vector<std::string>& vec_p_grids, std::string d_run_home, int n_threads, int n_grids_thread, int n_grids) {
  std::vector<UHBD_Grid*> vec_merged_grids(n_threads);
  int parts_merged_grid[n_threads];

  omp_set_num_threads(n_threads);
  #pragma omp parallel
  {
    int n_thread = omp_get_thread_num();
//    printf("launching number:  %d\n", n_thread);

    for (int i=0; i<n_grids_thread; i++) {
      int idx_p_grid = lists_p_grids[n_thread][i] - 1;

      if (idx_p_grid == -1) {
        // now done with grids for this thread
        break;
      }
      else {
        FILE* f_grid;
        std::string p_grid = vec_p_grids[idx_p_grid];
        if ((f_grid = fopen(p_grid.c_str(), "rb")) == NULL) {
          printf("Unable to open file: %s\n", p_grid.c_str());
        }
        // initialize the data_grid which will be used
        // only locally as it is reduced into the 
        // target grid, merged_grid
        UHBD_Grid* data_grid = Read_UHBD_Header(f_grid);
        data_grid->factor = 1 / (float)n_grids;
        data_grid->id = idx_p_grid;
//        printf("\nHeader check: x-dim = %d\n", data_grid->header.xm);
//        printf("\nFactor check: factor= %f\n", data_grid->factor);
        if (i == 0) {
          // this is where the target grid is initialized
          // it is locally accessed as merged_grid.
          // each thread uses n_thread as address within
          // vec_merged_grids so merger can level up.
          UHBD_Grid* merged_grid;
          merged_grid = Initialize_Target_Grid(data_grid);
          vec_merged_grids[n_thread] = merged_grid;
          //printf("target grid check: zm     =  %d\n", merged_grid->header.zm); 
          //printf("                 : [last] =  %f\n", merged_grid->blocks[50]->data[249999]); 
        }
        Read_UHBD_Grid(data_grid, f_grid);
        Reduce_UHBD_Grids(vec_merged_grids[n_thread], data_grid);
        printf("%d     From   file : %s\n", n_thread, p_grid.c_str());
        printf("%dtarget grid check: zm     =  %d\n", n_thread, vec_merged_grids[n_thread]->header.zm); 
        printf("%d                 : factor =  %f\n", n_thread, vec_merged_grids[n_thread]->factor);
        printf("%d                 : [non-0]=  %f\n", n_thread, vec_merged_grids[n_thread]->blocks[0]->data[127743]); 

        // WHY DOESN'T THIS WORK? WHY SEEMS UNNECESSARY (IS ONLY POINTER small leak, to set of pointers?)?
        // data_grid is newed line 1 of and returned by Read_UHBD_Header function
        //delete[] data_grid;
      }
    }
    // now create intermediate segments of final file
    // note this is not currently geared for 1 thread
    std::string p_merged_grid;
    FILE* f_merged_grid;

    // calculate interval for each thread
    // this algorithm creates a balanced 
    // partition of the grid blocks when 
    // applied over all threads (haven't
    // considered n_threads==1)
    #pragma omp single
    {
      printf("\n%d 2nd stage of merge: \n\tdetermining grid partitioning\n", n_thread);
      for (int i=0; i<n_threads; i++) {
        parts_merged_grid[i] = (i + 1) * (vec_merged_grids[0]->n_blocks / n_threads);
        if (i < vec_merged_grids[0]->n_blocks % n_threads) {
          parts_merged_grid[i] += i + 1;
        }
        else {
          parts_merged_grid[i] += vec_merged_grids[0]->n_blocks % n_threads;
        }
      }
    }
    //endof omp single
    p_merged_grid = d_run_home + "resid3d.bin.grd." + std::to_string(n_thread);
    if ((f_merged_grid = fopen(p_merged_grid.c_str(), "wb")) == NULL) {
      printf("Unable to open file: %s\n", p_merged_grid.c_str());
    }
    Merge_Write_UHBD_Grid(f_merged_grid, vec_merged_grids, parts_merged_grid, n_thread, n_threads);
  }
  //endof omp parallel
}


int Read_d_run (std::vector<std::string>& vec_p_grids, std::string d_run_home) {
  DIR* dir = opendir(d_run_home.c_str());
  struct dirent* entry = readdir(dir);

  while (entry != NULL) {
    std::string d_name = entry->d_name;
    if (d_name.find("set") == 0){
      std::string p_grid;
//      printf("%s\n", entry->d_name);
      p_grid = d_run_home + d_name + "/resid3d.bin.grd";
      vec_p_grids.push_back(p_grid);
    }
    entry = readdir(dir);
  }
  return vec_p_grids.size();
}


int main(int argc, char ** argv)
{
  // stuff used to get oriented with the set of grids
  std::string nm_group;
  std::string nm_run;
  std::string d_merge_home;
  std::string d_run_home;
  std::string d_header;
  std::string p_header;

  d_merge_home = "./";
  nm_group = argv[1];
  nm_run = argv[2];
  d_run_home = d_merge_home + "runs/" + nm_group + "/" + nm_run + "/";

  std::vector<std::string> vec_p_grids;
  int n_grids;
  int n_threads;
  int n_grids_thread;
  int n_grids_extra;
  int** lists_p_grids;

  n_grids = Read_d_run(vec_p_grids, d_run_home);
  n_threads = omp_get_n_threads();
  // incase of tortoises
  // also good for checks
  //n_threads = 1;
//  printf("check some stuff: 3   %d\n", n_threads);

  n_grids_thread = n_grids / n_threads;
  n_grids_extra  = n_grids % n_threads;
  if (n_grids_extra > 0) {
    n_grids_thread += 1;
  }

  lists_p_grids = new int *[n_threads];
  for (int i=0; i<n_grids_thread; i++) {
    for (int j=0; j<n_threads; j++) {
      if (i == 0) {
        // format is to start at 1, then if
        // a grid has the zero index (and is
        // the final entry as a check) we 
        // know it was unfilled in the extra
        // line: below is zero-init method
        lists_p_grids[j] = new int[n_grids_thread]();
      }
      int val = i * n_threads + j + 1;

      if (val > n_grids) {
        // leave this and remaining as zero
        break;
      }
      else {
        lists_p_grids[j][i] = val;
      }
    }
  }

  printf("\n\nMerging Grids in folder:  %s\n\n\nmerge config: \n\t\tn_grids: %d    n_threads: %d    n_grids_thread: %d\n\n", d_run_home.c_str(), n_grids, n_threads, n_grids_thread);

  for (int i=0; i<vec_p_grids.size(); i++) {
    printf("  grid# %d\t%s\n", i, vec_p_grids[i].c_str());
  }

  printf("\ngrids-threads breakdown:\n");
  for (int i=0; i<n_threads; i++) {
    printf("\t\tthread# %d)   ", i);
    for (int j=0; j<n_grids_thread; j++) {
      if (lists_p_grids[i][j] > 0) {
        printf("%d  ", lists_p_grids[i][j]);
      }
    }
    printf("\n");
  }
  printf("\n");

  Merge_UHBD_Grids(lists_p_grids, vec_p_grids, d_run_home, n_threads, n_grids_thread, n_grids);

  return 0;
}
